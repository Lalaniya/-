<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript 面试八股文大全（初级） | 前端面试</title>
    <meta name="description" content="前端面试">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/assets/style.xWaBtBkJ.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.DblBQE8y.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.0oUK0NHD.js">
    <link rel="modulepreload" href="/assets/chunks/framework.Dgg8-8ov.js">
    <link rel="modulepreload" href="/assets/start-Learning_js-interview-questions.md.DmHjffnW.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-7c803d7d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-fb09bc48></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-fb09bc48>Skip to content</a><!--]--><!----><header class="VPNav" data-v-7c803d7d data-v-d277ba5f><div class="VPNavBar" data-v-d277ba5f data-v-4eed335f><div class="wrapper" data-v-4eed335f><div class="container" data-v-4eed335f><div class="title" data-v-4eed335f><div class="VPNavBarTitle has-sidebar" data-v-4eed335f data-v-cc35f9f3><a class="title" href="/" data-v-cc35f9f3><!--[--><!--]--><!----><span data-v-cc35f9f3>前端面试</span><!--[--><!--]--></a></div></div><div class="content" data-v-4eed335f><div class="content-body" data-v-4eed335f><!--[--><!--]--><div class="VPNavBarSearch search" data-v-4eed335f><!----></div><!----><!----><div class="VPNavBarAppearance appearance" data-v-4eed335f data-v-e8ee28da><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-e8ee28da data-v-8c664956 data-v-bbc05ca6><span class="check" data-v-bbc05ca6><span class="icon" data-v-bbc05ca6><!--[--><span class="vpi-sun sun" data-v-8c664956></span><span class="vpi-moon moon" data-v-8c664956></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-4eed335f data-v-4c75ccfc data-v-29cdb75f><!--[--><a class="VPSocialLink no-icon" href="https://gitee.com/Lalaniya/js-interview" aria-label="github" target="_blank" rel="noopener" data-v-29cdb75f data-v-b957a459><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-4eed335f data-v-9d7447b4 data-v-019c94c2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-019c94c2><span class="vpi-more-horizontal icon" data-v-019c94c2></span></button><div class="menu" data-v-019c94c2><div class="VPMenu" data-v-019c94c2 data-v-8b2f3a7c><!----><!--[--><!--[--><!----><div class="group" data-v-9d7447b4><div class="item appearance" data-v-9d7447b4><p class="label" data-v-9d7447b4>Appearance</p><div class="appearance-action" data-v-9d7447b4><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-9d7447b4 data-v-8c664956 data-v-bbc05ca6><span class="check" data-v-bbc05ca6><span class="icon" data-v-bbc05ca6><!--[--><span class="vpi-sun sun" data-v-8c664956></span><span class="vpi-moon moon" data-v-8c664956></span><!--]--></span></span></button></div></div></div><div class="group" data-v-9d7447b4><div class="item social-links" data-v-9d7447b4><div class="VPSocialLinks social-links-list" data-v-9d7447b4 data-v-29cdb75f><!--[--><a class="VPSocialLink no-icon" href="https://gitee.com/Lalaniya/js-interview" aria-label="github" target="_blank" rel="noopener" data-v-29cdb75f data-v-b957a459><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-4eed335f data-v-2b155ee9><span class="container" data-v-2b155ee9><span class="top" data-v-2b155ee9></span><span class="middle" data-v-2b155ee9></span><span class="bottom" data-v-2b155ee9></span></span></button></div></div></div></div><div class="divider" data-v-4eed335f><div class="divider-line" data-v-4eed335f></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-7c803d7d data-v-64ac960c><div class="container" data-v-64ac960c><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-64ac960c><span class="vpi-align-left menu-icon" data-v-64ac960c></span><span class="menu-text" data-v-64ac960c>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-64ac960c data-v-2489f416><button data-v-2489f416>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-7c803d7d data-v-6d6aac87><div class="curtain" data-v-6d6aac87></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-6d6aac87><span class="visually-hidden" id="sidebar-aria-label" data-v-6d6aac87> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-0e54959d><section class="VPSidebarItem level-0 has-active" data-v-0e54959d data-v-6a1ca405><div class="item" role="button" tabindex="0" data-v-6a1ca405><div class="indicator" data-v-6a1ca405></div><h2 class="text" data-v-6a1ca405>开始学习</h2><!----></div><div class="items" data-v-6a1ca405><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6a1ca405 data-v-6a1ca405><div class="item" data-v-6a1ca405><div class="indicator" data-v-6a1ca405></div><a class="VPLink link link" href="/start-Learning/js-interview-questions.html" data-v-6a1ca405><!--[--><p class="text" data-v-6a1ca405>JS基础面试题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6a1ca405 data-v-6a1ca405><div class="item" data-v-6a1ca405><div class="indicator" data-v-6a1ca405></div><a class="VPLink link link" href="/start-Learning/js-intermediate-interview-questions.html" data-v-6a1ca405><!--[--><p class="text" data-v-6a1ca405>JS中级面试题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6a1ca405 data-v-6a1ca405><div class="item" data-v-6a1ca405><div class="indicator" data-v-6a1ca405></div><a class="VPLink link link" href="/start-Learning/js-advanced-interview-questions.html" data-v-6a1ca405><!--[--><p class="text" data-v-6a1ca405>JS高级面试题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6a1ca405 data-v-6a1ca405><div class="item" data-v-6a1ca405><div class="indicator" data-v-6a1ca405></div><a class="VPLink link link" href="/start-Learning/js-advanced-interview-questions-2.html" data-v-6a1ca405><!--[--><p class="text" data-v-6a1ca405>JS补充面试题</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-7c803d7d data-v-a5d3c0fe><div class="VPDoc has-sidebar has-aside" data-v-a5d3c0fe data-v-5a987885><!--[--><!--]--><div class="container" data-v-5a987885><div class="aside" data-v-5a987885><div class="aside-curtain" data-v-5a987885></div><div class="aside-container" data-v-5a987885><div class="aside-content" data-v-5a987885><div class="VPDocAside" data-v-5a987885 data-v-c5b8410c><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-c5b8410c data-v-78ab4f00><div class="content" data-v-78ab4f00><div class="outline-marker" data-v-78ab4f00></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-78ab4f00>On this page</div><ul class="VPDocOutlineItem root" data-v-78ab4f00 data-v-ca95a57c><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-c5b8410c></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-5a987885><div class="content-container" data-v-5a987885><!--[--><!--]--><main class="main" data-v-5a987885><div style="position:relative;" class="vp-doc _start-Learning_js-interview-questions" data-v-5a987885><div><h1 id="javascript-面试八股文大全-初级" tabindex="-1">JavaScript 面试八股文大全（初级） <a class="header-anchor" href="#javascript-面试八股文大全-初级" aria-label="Permalink to &quot;JavaScript 面试八股文大全（初级）&quot;">​</a></h1><h2 id="一、基础语法" tabindex="-1">一、基础语法 <a class="header-anchor" href="#一、基础语法" aria-label="Permalink to &quot;一、基础语法&quot;">​</a></h2><h3 id="_1-变量声明方式有哪些-有什么区别" tabindex="-1">1. 变量声明方式有哪些，有什么区别？ <a class="header-anchor" href="#_1-变量声明方式有哪些-有什么区别" aria-label="Permalink to &quot;1. 变量声明方式有哪些，有什么区别？&quot;">​</a></h3><p>在 JavaScript 中，变量声明方式主要有以下几种：</p><ul><li><code>var</code>：函数作用域，存在变量提升，可以重复声明。</li><li><code>let</code>：块级作用域，不存在变量提升，不允许重复声明。</li><li><code>const</code>：块级作用域，声明常量，一旦声明必须赋值，不能使用 null 占位。声明后不能再修改，如果声明的是引用类型，可以修改其内部属性。</li></ul><h3 id="_2-什么是变量提升" tabindex="-1">2. 什么是变量提升？ <a class="header-anchor" href="#_2-什么是变量提升" aria-label="Permalink to &quot;2. 什么是变量提升？&quot;">​</a></h3><p>变量提升是 JavaScript 的一个特性，指的是在 JavaScript 中，变量和函数的声明会被提升到当前作用域的顶部，因此可以在声明之前使用。需要注意的是，变量提升只提升声明，不提升赋值。</p><h3 id="_3-javascript-有哪些数据类型" tabindex="-1">3. JavaScript 有哪些数据类型？ <a class="header-anchor" href="#_3-javascript-有哪些数据类型" aria-label="Permalink to &quot;3. JavaScript 有哪些数据类型？&quot;">​</a></h3><p>JavaScript 有两种数据类型：</p><ul><li>基本数据类型（值类型）：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code>、<code>bigint</code>。</li><li>引用数据类型：<code>object</code>（包括普通对象、数组、函数、日期等）。</li></ul><h3 id="_4-如何判断数据类型" tabindex="-1">4. 如何判断数据类型？ <a class="header-anchor" href="#_4-如何判断数据类型" aria-label="Permalink to &quot;4. 如何判断数据类型？&quot;">​</a></h3><p>判断数据类型的方法有以下几种：</p><ul><li><code>typeof</code>：返回一个表示数据类型的字符串，对基本类型（除了<code>null</code>）有效，但对引用类型（除了函数）都返回<code>object</code>。</li><li><code>instanceof</code>：用于判断对象是否是某个构造函数的实例。</li><li><code>Object.prototype.toString.call()</code>：返回一个表示数据类型的字符串，能准确判断所有类型。</li><li><code>Array.isArray()</code>：专门用于判断是否为数组。</li><li><code>null</code>的判断需要使用<code>value === null</code>。</li></ul><h3 id="_5-null-和-undefined-的区别" tabindex="-1">5. null 和 undefined 的区别？ <a class="header-anchor" href="#_5-null-和-undefined-的区别" aria-label="Permalink to &quot;5. null 和 undefined 的区别？&quot;">​</a></h3><ul><li><code>null</code>：表示一个空对象指针，是一个原始值，可以被赋值。</li><li><code>undefined</code>：表示变量已声明但未赋值，或者函数没有返回值，或者访问不存在的属性。</li></ul><h3 id="_6-什么是深拷贝和浅拷贝" tabindex="-1">6. 什么是深拷贝和浅拷贝？ <a class="header-anchor" href="#_6-什么是深拷贝和浅拷贝" aria-label="Permalink to &quot;6. 什么是深拷贝和浅拷贝？&quot;">​</a></h3><ul><li>浅拷贝：只复制对象的一层属性，如果属性是引用类型，则只复制引用，而不复制对象本身。</li><li>深拷贝：递归复制对象的所有属性，创建一个完全独立的对象，修改新对象不会影响原对象。</li></ul><h3 id="_7-如何实现浅拷贝" tabindex="-1">7. 如何实现浅拷贝？ <a class="header-anchor" href="#_7-如何实现浅拷贝" aria-label="Permalink to &quot;7. 如何实现浅拷贝？&quot;">​</a></h3><p>浅拷贝的实现方法有以下几种：</p><ul><li>手动遍历对象，复制每一个属性。</li><li>使用<code>Object.assign()</code>方法。</li><li>使用扩展运算符<code>...</code>。</li></ul><h3 id="_8-如何实现深拷贝" tabindex="-1">8. 如何实现深拷贝？ <a class="header-anchor" href="#_8-如何实现深拷贝" aria-label="Permalink to &quot;8. 如何实现深拷贝？&quot;">​</a></h3><p>深拷贝的实现方法有以下几种：</p><ul><li>使用<code>JSON.parse(JSON.stringify())</code>，但这种方法有局限性，不能处理函数、正则、循环引用等。</li><li>递归遍历对象，复制每一个属性，如果属性是引用类型，则递归复制。</li></ul><h3 id="_9-什么是闭包" tabindex="-1">9. 什么是闭包？ <a class="header-anchor" href="#_9-什么是闭包" aria-label="Permalink to &quot;9. 什么是闭包？&quot;">​</a></h3><p>闭包是指有权访问另一个函数作用域中变量的函数。即使该函数已经执行完毕，其作用域内的变量也不会被销毁。</p><h3 id="_10-闭包的应用场景有哪些" tabindex="-1">10. 闭包的应用场景有哪些？ <a class="header-anchor" href="#_10-闭包的应用场景有哪些" aria-label="Permalink to &quot;10. 闭包的应用场景有哪些？&quot;">​</a></h3><p>闭包的应用场景包括：</p><ul><li>读取函数内部的变量。</li><li>让这些变量的值始终保持在内存中。</li><li>实现函数私有变量和方法。</li><li>模拟块级作用域。</li><li>实现函数柯里化。</li></ul><h3 id="_11-闭包的优缺点是什么" tabindex="-1">11. 闭包的优缺点是什么？ <a class="header-anchor" href="#_11-闭包的优缺点是什么" aria-label="Permalink to &quot;11. 闭包的优缺点是什么？&quot;">​</a></h3><p>优点：</p><ul><li>可以读取函数内部的变量。</li><li>可以让这些变量的值始终保持在内存中。</li></ul><p>缺点：</p><ul><li>闭包会使得函数中的变量都被保存在内存中，内存消耗大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。</li><li>闭包可能在父函数外部，改变父函数内部变量的值。</li></ul><h3 id="_12-如何避免闭包引起的内存泄漏" tabindex="-1">12. 如何避免闭包引起的内存泄漏？ <a class="header-anchor" href="#_12-如何避免闭包引起的内存泄漏" aria-label="Permalink to &quot;12. 如何避免闭包引起的内存泄漏？&quot;">​</a></h3><ul><li>及时释放闭包引用的变量。</li><li>在不需要闭包时，将闭包设置为<code>null</code>。</li></ul><h3 id="_13-什么是立即执行函数表达式-iife" tabindex="-1">13. 什么是立即执行函数表达式（IIFE）？ <a class="header-anchor" href="#_13-什么是立即执行函数表达式-iife" aria-label="Permalink to &quot;13. 什么是立即执行函数表达式（IIFE）？&quot;">​</a></h3><p>立即执行函数表达式（IIFE）是一种在定义后立即执行的 JavaScript 函数。其语法形式为：(function() { // 函数体 })();或者(function() { // 函数体 }());</p><h3 id="_14-iife-的作用是什么" tabindex="-1">14. IIFE 的作用是什么？ <a class="header-anchor" href="#_14-iife-的作用是什么" aria-label="Permalink to &quot;14. IIFE 的作用是什么？&quot;">​</a></h3><p>IIFE 的作用包括：</p><ul><li>创建独立的作用域，避免全局变量污染。</li><li>执行一次性的任务。</li><li>在模块模式中使用，实现私有变量和方法。</li></ul><h3 id="_15-什么是箭头函数" tabindex="-1">15. 什么是箭头函数？ <a class="header-anchor" href="#_15-什么是箭头函数" aria-label="Permalink to &quot;15. 什么是箭头函数？&quot;">​</a></h3><p>箭头函数是 ES6 中引入的一种函数简写形式，使用箭头<code>=&gt;</code>定义函数。其语法形式为：const sum = (a, b) =&gt; a + b;</p><h3 id="_16-箭头函数与普通函数有什么区别" tabindex="-1">16. 箭头函数与普通函数有什么区别？ <a class="header-anchor" href="#_16-箭头函数与普通函数有什么区别" aria-label="Permalink to &quot;16. 箭头函数与普通函数有什么区别？&quot;">​</a></h3><ul><li>箭头函数没有自己的<code>this</code>，它的<code>this</code>继承自父级作用域。</li><li>箭头函数不能使用<code>arguments</code>对象。</li><li>箭头函数不能使用<code>yield</code>关键字，因此不能用作生成器函数。</li><li>箭头函数不能使用<code>new</code>关键字实例化。</li><li>箭头函数的语法更加简洁。</li></ul><h3 id="_17-什么是函数柯里化" tabindex="-1">17. 什么是函数柯里化？ <a class="header-anchor" href="#_17-什么是函数柯里化" aria-label="Permalink to &quot;17. 什么是函数柯里化？&quot;">​</a></h3><p>函数柯里化是指将一个多参数函数转换为一系列单参数函数的技术。例如，将函数<code>f(a, b)</code>转换为<code>f(a)(b)</code>。</p><h3 id="_18-函数柯里化的作用是什么" tabindex="-1">18. 函数柯里化的作用是什么？ <a class="header-anchor" href="#_18-函数柯里化的作用是什么" aria-label="Permalink to &quot;18. 函数柯里化的作用是什么？&quot;">​</a></h3><ul><li>参数复用。</li><li>延迟计算。</li><li>提前绑定参数。</li></ul><h3 id="_19-如何实现函数柯里化" tabindex="-1">19. 如何实现函数柯里化？ <a class="header-anchor" href="#_19-如何实现函数柯里化" aria-label="Permalink to &quot;19. 如何实现函数柯里化？&quot;">​</a></h3><p>可以通过递归返回一个新函数来实现柯里化，每次调用时收集参数，当参数数量足够时执行原函数。例如：function curry(func) { return function curried(...args) { if (args.length &gt;= func.length) { return func.apply(this, args); } else { return function(...moreArgs) { return curried.apply(this, args.concat(moreArgs)); } } }; }</p><h3 id="_20-什么是递归" tabindex="-1">20. 什么是递归？ <a class="header-anchor" href="#_20-什么是递归" aria-label="Permalink to &quot;20. 什么是递归？&quot;">​</a></h3><p>递归是指在函数的定义中使用函数自身的方法。递归函数通常包含两个部分：基线条件（终止条件）和递归条件。</p><h3 id="_21-递归的优缺点是什么" tabindex="-1">21. 递归的优缺点是什么？ <a class="header-anchor" href="#_21-递归的优缺点是什么" aria-label="Permalink to &quot;21. 递归的优缺点是什么？&quot;">​</a></h3><p>优点：</p><ul><li>代码简洁、清晰。</li><li>易于理解和实现。</li></ul><p>缺点：</p><ul><li>可能导致栈溢出，特别是在递归深度很大时。</li><li>性能可能不如迭代。</li></ul><h3 id="_22-如何避免递归引起的栈溢出" tabindex="-1">22. 如何避免递归引起的栈溢出？ <a class="header-anchor" href="#_22-如何避免递归引起的栈溢出" aria-label="Permalink to &quot;22. 如何避免递归引起的栈溢出？&quot;">​</a></h3><ul><li>使用尾递归优化，确保递归调用是函数的最后一个操作。</li><li>将递归转换为迭代。</li></ul><h3 id="_23-什么是尾递归" tabindex="-1">23. 什么是尾递归？ <a class="header-anchor" href="#_23-什么是尾递归" aria-label="Permalink to &quot;23. 什么是尾递归？&quot;">​</a></h3><p>尾递归是指递归调用是函数的最后一个操作，这样可以避免栈溢出。尾递归优化需要语言或环境的支持。</p><h3 id="_24-javascript-中的-this-指向什么" tabindex="-1">24. JavaScript 中的 this 指向什么？ <a class="header-anchor" href="#_24-javascript-中的-this-指向什么" aria-label="Permalink to &quot;24. JavaScript 中的 this 指向什么？&quot;">​</a></h3><p><code>this</code>的指向取决于函数的调用方式，主要有以下几种情况：</p><ul><li>全局作用域中，<code>this</code>指向全局对象（浏览器中是<code>window</code>）。</li><li>函数作为方法调用时，<code>this</code>指向调用该方法的对象。</li><li>函数作为构造函数调用时，<code>this</code>指向新创建的对象。</li><li>函数使用<code>call</code>、<code>apply</code>或<code>bind</code>方法调用时，<code>this</code>指向第一个参数指定的对象。</li><li>箭头函数中的<code>this</code>继承自父级作用域。</li></ul><h3 id="_25-如何改变函数内部-this-的指向" tabindex="-1">25. 如何改变函数内部 this 的指向？ <a class="header-anchor" href="#_25-如何改变函数内部-this-的指向" aria-label="Permalink to &quot;25. 如何改变函数内部 this 的指向？&quot;">​</a></h3><p>可以使用以下方法改变函数内部<code>this</code>的指向：</p><ul><li><code>call()</code>：第一个参数指定<code>this</code>的指向，后面的参数是函数的参数。</li><li><code>apply()</code>：第一个参数指定<code>this</code>的指向，第二个参数是一个数组，包含函数的参数。</li><li><code>bind()</code>：创建一个新函数，在调用时<code>this</code>值会被绑定到第一个参数指定的对象上。</li></ul><h2 id="二、数组方法" tabindex="-1">二、数组方法 <a class="header-anchor" href="#二、数组方法" aria-label="Permalink to &quot;二、数组方法&quot;">​</a></h2><h3 id="_26-数组常用的方法有哪些" tabindex="-1">26. 数组常用的方法有哪些？ <a class="header-anchor" href="#_26-数组常用的方法有哪些" aria-label="Permalink to &quot;26. 数组常用的方法有哪些？&quot;">​</a></h3><p>数组常用的方法包括：</p><ul><li>增：<code>push()</code>、<code>unshift()</code>、<code>splice()</code>、<code>concat()</code></li><li>删：<code>pop()</code>、<code>shift()</code>、<code>splice()</code>、<code>slice()</code></li><li>改：<code>splice()</code>、<code>fill()</code></li><li>查：<code>indexOf()</code>、<code>lastIndexOf()</code>、<code>includes()</code>、<code>find()</code>、<code>findIndex()</code></li><li>遍历：<code>forEach()</code>、<code>map()</code>、<code>filter()</code>、<code>reduce()</code>、<code>some()</code>、<code>every()</code></li><li>排序：<code>sort()</code>、<code>reverse()</code></li><li>排序：<code>sort()</code>、<code>reverse()</code></li><li>转换：<code>join()</code>、<code>split()</code>、<code>toString()</code></li><li>其他：<code>flat()</code>、<code>flatMap()</code>、<code>copyWithin()</code></li></ul><h3 id="_27-push-方法的作用和返回值是什么" tabindex="-1">27. push()方法的作用和返回值是什么？ <a class="header-anchor" href="#_27-push-方法的作用和返回值是什么" aria-label="Permalink to &quot;27. push()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>push()</code>方法用于在数组的末尾添加一个或多个元素，并返回新数组的长度。</p><h3 id="_28-pop-方法的作用和返回值是什么" tabindex="-1">28. pop()方法的作用和返回值是什么？ <a class="header-anchor" href="#_28-pop-方法的作用和返回值是什么" aria-label="Permalink to &quot;28. pop()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>pop()</code>方法用于删除数组的最后一个元素，并返回被删除的元素。</p><h3 id="_29-shift-方法的作用和返回值是什么" tabindex="-1">29. shift()方法的作用和返回值是什么？ <a class="header-anchor" href="#_29-shift-方法的作用和返回值是什么" aria-label="Permalink to &quot;29. shift()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>shift()</code>方法用于删除数组的第一个元素，并返回被删除的元素。</p><h3 id="_30-unshift-方法的作用和返回值是什么" tabindex="-1">30. unshift()方法的作用和返回值是什么？ <a class="header-anchor" href="#_30-unshift-方法的作用和返回值是什么" aria-label="Permalink to &quot;30. unshift()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>unshift()</code>方法用于在数组的开头添加一个或多个元素，并返回新数组的长度。</p><h3 id="_31-splice-方法的作用和返回值是什么" tabindex="-1">31. splice()方法的作用和返回值是什么？ <a class="header-anchor" href="#_31-splice-方法的作用和返回值是什么" aria-label="Permalink to &quot;31. splice()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>splice()</code>方法用于添加或删除数组中的元素，并返回被删除的元素组成的数组。语法：<code>array.splice(start, deleteCount, item1, item2, ...)</code>。</p><h3 id="_32-slice-方法的作用和返回值是什么" tabindex="-1">32. slice()方法的作用和返回值是什么？ <a class="header-anchor" href="#_32-slice-方法的作用和返回值是什么" aria-label="Permalink to &quot;32. slice()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>slice()</code>方法用于从原数组中截取一部分元素组成新数组，并返回新数组。语法：<code>array.slice(start, end)</code>，截取从<code>start</code>到<code>end</code>（不包括<code>end</code>）的元素。</p><h3 id="_33-concat-方法的作用和返回值是什么" tabindex="-1">33. concat()方法的作用和返回值是什么？ <a class="header-anchor" href="#_33-concat-方法的作用和返回值是什么" aria-label="Permalink to &quot;33. concat()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>concat()</code>方法用于合并两个或多个数组，并返回一个新数组。</p><h3 id="_34-join-方法的作用和返回值是什么" tabindex="-1">34. join()方法的作用和返回值是什么？ <a class="header-anchor" href="#_34-join-方法的作用和返回值是什么" aria-label="Permalink to &quot;34. join()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>join()</code>方法用于将数组的所有元素连接成一个字符串，并返回该字符串。默认使用逗号作为分隔符。</p><h3 id="_35-reverse-方法的作用和返回值是什么" tabindex="-1">35. reverse()方法的作用和返回值是什么？ <a class="header-anchor" href="#_35-reverse-方法的作用和返回值是什么" aria-label="Permalink to &quot;35. reverse()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>reverse()</code>方法用于颠倒数组中元素的顺序，并返回颠倒后的数组。</p><h3 id="_36-sort-方法的作用和返回值是什么" tabindex="-1">36. sort()方法的作用和返回值是什么？ <a class="header-anchor" href="#_36-sort-方法的作用和返回值是什么" aria-label="Permalink to &quot;36. sort()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>sort()</code>方法用于对数组的元素进行排序，并返回排序后的数组。默认情况下，<code>sort()</code>方法会将元素转换为字符串，然后按照 Unicode 编码进行排序。可以传入一个比较函数来指定排序规则。</p><h3 id="_37-map-方法的作用和返回值是什么" tabindex="-1">37. map()方法的作用和返回值是什么？ <a class="header-anchor" href="#_37-map-方法的作用和返回值是什么" aria-label="Permalink to &quot;37. map()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>map()</code>方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。返回一个新数组，新数组中的元素是原数组中每个元素经过处理后的结果。</p><h3 id="_38-filter-方法的作用和返回值是什么" tabindex="-1">38. filter()方法的作用和返回值是什么？ <a class="header-anchor" href="#_38-filter-方法的作用和返回值是什么" aria-label="Permalink to &quot;38. filter()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>filter()</code>方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。返回一个新数组，新数组中的元素是原数组中满足条件的元素。</p><h3 id="_39-reduce-方法的作用和返回值是什么" tabindex="-1">39. reduce()方法的作用和返回值是什么？ <a class="header-anchor" href="#_39-reduce-方法的作用和返回值是什么" aria-label="Permalink to &quot;39. reduce()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>reduce()</code>方法对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。返回一个累计结果。</p><h3 id="_40-foreach-方法的作用和返回值是什么" tabindex="-1">40. forEach()方法的作用和返回值是什么？ <a class="header-anchor" href="#_40-foreach-方法的作用和返回值是什么" aria-label="Permalink to &quot;40. forEach()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>forEach()</code>方法对数组的每个元素执行一次提供的函数。没有返回值（返回<code>undefined</code>）。</p><h3 id="_41-some-方法的作用和返回值是什么" tabindex="-1">41. some()方法的作用和返回值是什么？ <a class="header-anchor" href="#_41-some-方法的作用和返回值是什么" aria-label="Permalink to &quot;41. some()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>some()</code>方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个布尔值。</p><h3 id="_42-every-方法的作用和返回值是什么" tabindex="-1">42. every()方法的作用和返回值是什么？ <a class="header-anchor" href="#_42-every-方法的作用和返回值是什么" aria-label="Permalink to &quot;42. every()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>every()</code>方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p><h3 id="_43-find-方法的作用和返回值是什么" tabindex="-1">43. find()方法的作用和返回值是什么？ <a class="header-anchor" href="#_43-find-方法的作用和返回值是什么" aria-label="Permalink to &quot;43. find()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>find()</code>方法返回数组中满足提供的测试函数的第一个元素的值。否则返回<code>undefined</code>。</p><h3 id="_44-findindex-方法的作用和返回值是什么" tabindex="-1">44. findIndex()方法的作用和返回值是什么？ <a class="header-anchor" href="#_44-findindex-方法的作用和返回值是什么" aria-label="Permalink to &quot;44. findIndex()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。</p><h3 id="_45-includes-方法的作用和返回值是什么" tabindex="-1">45. includes()方法的作用和返回值是什么？ <a class="header-anchor" href="#_45-includes-方法的作用和返回值是什么" aria-label="Permalink to &quot;45. includes()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>includes()</code>方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回<code>true</code>，否则返回<code>false</code>。</p><h3 id="_46-flat-方法的作用和返回值是什么" tabindex="-1">46. flat()方法的作用和返回值是什么？ <a class="header-anchor" href="#_46-flat-方法的作用和返回值是什么" aria-label="Permalink to &quot;46. flat()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>flat()</code>方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p><h3 id="_47-flatmap-方法的作用和返回值是什么" tabindex="-1">47. flatMap()方法的作用和返回值是什么？ <a class="header-anchor" href="#_47-flatmap-方法的作用和返回值是什么" aria-label="Permalink to &quot;47. flatMap()方法的作用和返回值是什么？&quot;">​</a></h3><p><code>flatMap()</code>方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与<code>map</code>连着深度值为 1 的<code>flat</code>几乎相同，但<code>flatMap</code>通常在合并成一种方法的效率稍微高一些。</p><h2 id="三、对象操作" tabindex="-1">三、对象操作 <a class="header-anchor" href="#三、对象操作" aria-label="Permalink to &quot;三、对象操作&quot;">​</a></h2><h3 id="_48-如何创建对象" tabindex="-1">48. 如何创建对象？ <a class="header-anchor" href="#_48-如何创建对象" aria-label="Permalink to &quot;48. 如何创建对象？&quot;">​</a></h3><p>创建对象的方法有以下几种：</p><ul><li>对象字面量：<code>const obj = { key: value };</code></li><li>使用<code>new Object()</code>：<code>const obj = new Object();</code></li><li>使用构造函数：<code>function Person(name) { this.name = name; } const person = new Person(&#39;John&#39;);</code></li><li>使用<code>Object.create()</code>：<code>const obj = Object.create(null);</code></li><li>使用类（ES6）：<code>class Person { constructor(name) { this.name = name; } } const person = new Person(&#39;John&#39;);</code></li></ul><h3 id="_49-如何遍历对象" tabindex="-1">49. 如何遍历对象？ <a class="header-anchor" href="#_49-如何遍历对象" aria-label="Permalink to &quot;49. 如何遍历对象？&quot;">​</a></h3><p>遍历对象的方法有以下几种：</p><ul><li><code>for...in</code>循环：遍历对象自身的和继承的可枚举属性（不包括 Symbol 属性）。</li><li><code>Object.keys()</code>：返回一个由对象自身的可枚举属性组成的数组。</li><li><code>Object.values()</code>：返回一个由对象自身的可枚举属性值组成的数组。</li><li><code>Object.entries()</code>：返回一个由对象自身的可枚举属性[key, value]组成的数组。</li><li><code>Object.getOwnPropertyNames()</code>：返回一个由对象自身的所有属性（包括不可枚举属性但不包括 Symbol 属性）组成的数组。</li><li><code>Reflect.ownKeys()</code>：返回一个由对象自身的所有属性（包括不可枚举属性和 Symbol 属性）组成的数组。</li></ul><h3 id="_50-如何判断对象是否有某个属性" tabindex="-1">50. 如何判断对象是否有某个属性？ <a class="header-anchor" href="#_50-如何判断对象是否有某个属性" aria-label="Permalink to &quot;50. 如何判断对象是否有某个属性？&quot;">​</a></h3><p>判断对象是否有某个属性的方法有以下几种：</p><ul><li><code>in</code>运算符：<code>&#39;key&#39; in obj</code>，包括对象自身的和继承的属性。</li><li><code>hasOwnProperty()</code>方法：<code>obj.hasOwnProperty(&#39;key&#39;)</code>，只检查对象自身的属性。</li><li><code>Object.prototype.hasOwnProperty.call(obj, &#39;key&#39;)</code>：更安全的检查方法，避免对象自身的<code>hasOwnProperty</code>方法被覆盖。</li></ul><h3 id="_51-如何合并对象" tabindex="-1">51. 如何合并对象？ <a class="header-anchor" href="#_51-如何合并对象" aria-label="Permalink to &quot;51. 如何合并对象？&quot;">​</a></h3><p>合并对象的方法有以下几种：</p><ul><li>手动遍历对象，复制每一个属性。</li><li>使用<code>Object.assign()</code>方法：浅拷贝，合并多个源对象的所有可枚举属性到目标对象。</li><li>使用扩展运算符<code>...</code>：浅拷贝，创建一个新对象，包含原对象的所有属性。</li><li>递归合并（深拷贝）：使用递归方法处理嵌套对象。</li></ul><h3 id="_52-什么是原型链" tabindex="-1">52. 什么是原型链？ <a class="header-anchor" href="#_52-什么是原型链" aria-label="Permalink to &quot;52. 什么是原型链？&quot;">​</a></h3><p>原型链是 JavaScript 中实现继承的一种方式。每个对象都有一个内部属性<code>[[Prototype]]</code>（在 JavaScript 中可以通过<code>__proto__</code>属性访问），它指向该对象的原型对象。当访问一个对象的属性时，JavaScript 首先在该对象本身查找，如果找不到，则在该对象的原型对象中查找，以此类推，直到找到该属性或到达原型链的末尾（即<code>Object.prototype</code>）。</p><h3 id="_53-如何实现对象的继承" tabindex="-1">53. 如何实现对象的继承？ <a class="header-anchor" href="#_53-如何实现对象的继承" aria-label="Permalink to &quot;53. 如何实现对象的继承？&quot;">​</a></h3><p>实现对象继承的方法有以下几种：</p><ul><li>原型链继承：通过原型对象实现继承。</li><li>构造函数继承：在子类构造函数中调用父类构造函数。</li><li>组合继承：结合原型链继承和构造函数继承。</li><li>寄生组合继承：优化组合继承，减少不必要的父类构造函数调用。</li><li>类继承（ES6）：使用<code>class</code>和<code>extends</code>关键字实现继承。</li></ul><h3 id="_54-什么是-es6-的类" tabindex="-1">54. 什么是 ES6 的类？ <a class="header-anchor" href="#_54-什么是-es6-的类" aria-label="Permalink to &quot;54. 什么是 ES6 的类？&quot;">​</a></h3><p>ES6 的类是一种语法糖，用于实现面向对象编程。类实际上是一个函数，它使用<code>class</code>关键字定义，并且有一个特殊的<code>constructor</code>方法用于创建对象。类可以有方法、静态方法和 getter/setter。</p><h3 id="_55-类和构造函数的区别是什么" tabindex="-1">55. 类和构造函数的区别是什么？ <a class="header-anchor" href="#_55-类和构造函数的区别是什么" aria-label="Permalink to &quot;55. 类和构造函数的区别是什么？&quot;">​</a></h3><ul><li>类是一种语法糖，本质上还是函数。</li><li>类不能直接调用，必须使用<code>new</code>关键字。</li><li>类中的方法不可枚举。</li><li>类中的所有代码自动运行在严格模式下。</li><li>类有静态属性和方法，使用<code>static</code>关键字定义。</li></ul><h3 id="_56-什么是类的静态方法和实例方法" tabindex="-1">56. 什么是类的静态方法和实例方法？ <a class="header-anchor" href="#_56-什么是类的静态方法和实例方法" aria-label="Permalink to &quot;56. 什么是类的静态方法和实例方法？&quot;">​</a></h3><ul><li>静态方法：使用<code>static</code>关键字定义的方法，属于类本身，而不是类的实例。可以通过类名直接调用，不能通过实例调用。</li><li>实例方法：定义在类的原型上的方法，属于类的实例。必须通过实例调用。</li></ul><h3 id="_57-什么是类的继承" tabindex="-1">57. 什么是类的继承？ <a class="header-anchor" href="#_57-什么是类的继承" aria-label="Permalink to &quot;57. 什么是类的继承？&quot;">​</a></h3><p>类的继承是指一个类（子类）可以继承另一个类（父类）的属性和方法。在 ES6 中，可以使用<code>extends</code>关键字实现类的继承。子类可以重写父类的方法，也可以添加新的方法。</p><h3 id="_58-什么是-super-关键字" tabindex="-1">58. 什么是 super 关键字？ <a class="header-anchor" href="#_58-什么是-super-关键字" aria-label="Permalink to &quot;58. 什么是 super 关键字？&quot;">​</a></h3><p><code>super</code>关键字用于访问和调用一个对象的父类（超类）。在构造函数中使用<code>super()</code>调用父类的构造函数；在方法中使用<code>super.method()</code>调用父类的方法。</p><h2 id="四、异步编程" tabindex="-1">四、异步编程 <a class="header-anchor" href="#四、异步编程" aria-label="Permalink to &quot;四、异步编程&quot;">​</a></h2><h3 id="_59-什么是异步编程" tabindex="-1">59. 什么是异步编程？ <a class="header-anchor" href="#_59-什么是异步编程" aria-label="Permalink to &quot;59. 什么是异步编程？&quot;">​</a></h3><p>异步编程是一种编程范式，允许程序在等待某个操作完成的同时继续执行其他任务。在 JavaScript 中，异步操作非常常见，例如网络请求、文件读写、定时器等。</p><h3 id="_60-为什么需要异步编程" tabindex="-1">60. 为什么需要异步编程？ <a class="header-anchor" href="#_60-为什么需要异步编程" aria-label="Permalink to &quot;60. 为什么需要异步编程？&quot;">​</a></h3><p>JavaScript 是单线程的，即在同一时间只能执行一个任务。如果没有异步编程，当执行一个耗时操作（如网络请求）时，整个程序会被阻塞，用户界面会变得卡顿甚至无响应。异步编程可以让程序在等待耗时操作完成的同时继续执行其他任务，提高程序的性能和用户体验。</p><h3 id="_61-javascript-中实现异步编程的方式有哪些" tabindex="-1">61. JavaScript 中实现异步编程的方式有哪些？ <a class="header-anchor" href="#_61-javascript-中实现异步编程的方式有哪些" aria-label="Permalink to &quot;61. JavaScript 中实现异步编程的方式有哪些？&quot;">​</a></h3><p>JavaScript 中实现异步编程的方式有以下几种：</p><ul><li>回调函数</li><li>事件监听</li><li>Promise</li><li>async/await</li><li>Generator 函数</li></ul><h3 id="_62-什么是回调函数" tabindex="-1">62. 什么是回调函数？ <a class="header-anchor" href="#_62-什么是回调函数" aria-label="Permalink to &quot;62. 什么是回调函数？&quot;">​</a></h3><p>回调函数是作为参数传递给另一个函数的函数，当那个函数执行完后，回调函数才会被调用。回调函数是 JavaScript 中实现异步编程的最基本方式。</p><h3 id="_63-什么是回调地狱" tabindex="-1">63. 什么是回调地狱？ <a class="header-anchor" href="#_63-什么是回调地狱" aria-label="Permalink to &quot;63. 什么是回调地狱？&quot;">​</a></h3><p>回调地狱是指在使用回调函数实现异步操作时，多个回调函数嵌套使用导致的代码结构混乱、可读性差的问题。例如：asyncOperation1(function(result1) { asyncOperation2(result1, function(result2) { asyncOperation3(result2, function(result3) { // 更多嵌套... }); }); });</p><h3 id="_64-如何解决回调地狱" tabindex="-1">64. 如何解决回调地狱？ <a class="header-anchor" href="#_64-如何解决回调地狱" aria-label="Permalink to &quot;64. 如何解决回调地狱？&quot;">​</a></h3><p>解决回调地狱的方法有以下几种：</p><ul><li>使用 Promise：将回调函数转换为 Promise，使用<code>then()</code>方法链式调用。</li><li>使用 async/await：基于 Promise 的语法糖，使异步代码看起来更像同步代码。</li><li>使用模块化：将异步操作封装成独立的模块，减少嵌套。</li><li>使用 Generator 函数：结合 Promise 实现异步流程控制。</li></ul><h3 id="_65-什么是-promise" tabindex="-1">65. 什么是 Promise？ <a class="header-anchor" href="#_65-什么是-promise" aria-label="Permalink to &quot;65. 什么是 Promise？&quot;">​</a></h3><p>Promise 是 ES6 中引入的一种处理异步操作的对象，它代表一个异步操作的最终完成（或失败）及其结果值。Promise 有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。状态一旦改变，就会永久保持该状态，不会再发生变化。</p><h3 id="_66-promise-的常用方法有哪些" tabindex="-1">66. Promise 的常用方法有哪些？ <a class="header-anchor" href="#_66-promise-的常用方法有哪些" aria-label="Permalink to &quot;66. Promise 的常用方法有哪些？&quot;">​</a></h3><p>Promise 的常用方法包括：</p><ul><li><code>then()</code>：处理 Promise 成功的情况，返回一个新的 Promise。</li><li><code>catch()</code>：处理 Promise 失败的情况，返回一个新的 Promise。</li><li><code>finally()</code>：无论 Promise 状态如何都会执行，返回一个新的 Promise。</li><li><code>all()</code>：并行处理多个 Promise，当所有 Promise 都成功时返回一个包含所有结果的数组，只要有一个失败就立即返回失败的结果。</li><li><code>race()</code>：并行处理多个 Promise，哪个 Promise 最先完成就返回哪个 Promise 的结果。</li><li><code>allSettled()</code>：并行处理多个 Promise，返回一个包含所有 Promise 结果的数组，无论每个 Promise 是否成功。</li><li><code>any()</code>：并行处理多个 Promise，只要有一个 Promise 成功就返回该 Promise 的结果，只有当所有 Promise 都失败时才返回失败。</li></ul><h3 id="_67-如何创建一个-promise" tabindex="-1">67. 如何创建一个 Promise？ <a class="header-anchor" href="#_67-如何创建一个-promise" aria-label="Permalink to &quot;67. 如何创建一个 Promise？&quot;">​</a></h3><p>可以使用 Promise 构造函数创建一个 Promise，构造函数接受一个执行器函数，该函数有两个参数：<code>resolve</code>和<code>reject</code>，分别用于将 Promise 状态从<code>pending</code>变为<code>fulfilled</code>和<code>rejected</code>。例如：const promise = new Promise((resolve, reject) =&gt; { // 异步操作 setTimeout(() =&gt; { const success = true; if (success) { resolve(&#39;操作成功&#39;); } else { reject(&#39;操作失败&#39;); } }, 1000); });</p><h3 id="_68-什么是-async-await" tabindex="-1">68. 什么是 async/await？ <a class="header-anchor" href="#_68-什么是-async-await" aria-label="Permalink to &quot;68. 什么是 async/await？&quot;">​</a></h3><p>async/await 是 ES8 中引入的一种异步编程的语法糖，它基于 Promise 实现，使异步代码看起来更像同步代码，提高了代码的可读性和可维护性。<code>async</code>函数总是返回一个 Promise，<code>await</code>关键字只能在<code>async</code>函数内部使用，用于等待一个 Promise 的解决，并返回其结果。</p><h3 id="_69-async-await-的优点是什么" tabindex="-1">69. async/await 的优点是什么？ <a class="header-anchor" href="#_69-async-await-的优点是什么" aria-label="Permalink to &quot;69. async/await 的优点是什么？&quot;">​</a></h3><ul><li>代码更清晰、更易读，接近同步代码的写法。</li><li>错误处理更方便，可以使用传统的<code>try...catch</code>结构。</li><li>调试更容易，可以像调试同步代码一样设置断点。</li><li>可以使用<code>for...of</code>、<code>Promise.all</code>等同步风格的控制结构。</li></ul><h3 id="_70-如何处理-async-await-中的错误" tabindex="-1">70. 如何处理 async/await 中的错误？ <a class="header-anchor" href="#_70-如何处理-async-await-中的错误" aria-label="Permalink to &quot;70. 如何处理 async/await 中的错误？&quot;">​</a></h3><p>处理 async/await 中的错误有以下几种方法：</p><ul><li>使用<code>try...catch</code>块包裹<code>await</code>语句。</li><li>在<code>async</code>函数外部使用<code>.catch()</code>处理 Promise 的拒绝。</li><li>对单个 Promise 使用<code>.catch()</code>处理错误。</li></ul><h3 id="_71-什么是事件循环-event-loop" tabindex="-1">71. 什么是事件循环（Event Loop）？ <a class="header-anchor" href="#_71-什么是事件循环-event-loop" aria-label="Permalink to &quot;71. 什么是事件循环（Event Loop）？&quot;">​</a></h3><p>事件循环是 JavaScript 的执行机制，负责处理异步操作。JavaScript 是单线程的，所有任务都需要在主线程上执行。当遇到异步任务时，会将其放入任务队列中，等到主线程上的任务执行完毕后，事件循环会从任务队列中取出任务并执行。</p><h3 id="_72-事件循环的工作原理是什么" tabindex="-1">72. 事件循环的工作原理是什么？ <a class="header-anchor" href="#_72-事件循环的工作原理是什么" aria-label="Permalink to &quot;72. 事件循环的工作原理是什么？&quot;">​</a></h3><p>事件循环的工作原理可以概括为以下几个步骤：</p><ol><li>主线程执行同步代码，形成执行栈。</li><li>遇到异步任务时，将其放入任务队列（宏任务队列或微任务队列）。</li><li>主线程上的同步任务执行完毕后，执行栈为空。</li><li>事件循环开始工作，从微任务队列中取出所有任务并执行，直到微任务队列为空。</li><li>从宏任务队列中取出一个任务执行。</li><li>重复步骤 4 和 5。</li></ol><h3 id="_73-什么是宏任务和微任务" tabindex="-1">73. 什么是宏任务和微任务？ <a class="header-anchor" href="#_73-什么是宏任务和微任务" aria-label="Permalink to &quot;73. 什么是宏任务和微任务？&quot;">​</a></h3><ul><li>宏任务：包括整体代码（script）、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（Node.js）、<code>requestAnimationFrame</code>（浏览器）、I/O 操作、UI 渲染等。</li><li>微任务：包括<code>Promise.then</code>、<code>Promise.catch</code>、<code>Promise.finally</code>、<code>process.nextTick</code>（Node.js）、<code>MutationObserver</code>（浏览器）等。</li></ul><h3 id="_74-微任务和宏任务的执行顺序是怎样的" tabindex="-1">74. 微任务和宏任务的执行顺序是怎样的？ <a class="header-anchor" href="#_74-微任务和宏任务的执行顺序是怎样的" aria-label="Permalink to &quot;74. 微任务和宏任务的执行顺序是怎样的？&quot;">​</a></h3><p>微任务的执行优先级高于宏任务。每次事件循环开始时，会先执行完所有微任务，然后再执行一个宏任务，接着再执行完所有微任务，以此类推。</p><h2 id="五、dom-操作" tabindex="-1">五、DOM 操作 <a class="header-anchor" href="#五、dom-操作" aria-label="Permalink to &quot;五、DOM 操作&quot;">​</a></h2><h3 id="_75-什么是-dom" tabindex="-1">75. 什么是 DOM？ <a class="header-anchor" href="#_75-什么是-dom" aria-label="Permalink to &quot;75. 什么是 DOM？&quot;">​</a></h3><p>DOM（Document Object Model）即文档对象模型，是 HTML 和 XML 文档的编程接口。它将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合，允许程序和脚本动态地访问和修改文档的内容、结构和样式。</p><h3 id="_76-如何选择-dom-元素" tabindex="-1">76. 如何选择 DOM 元素？ <a class="header-anchor" href="#_76-如何选择-dom-元素" aria-label="Permalink to &quot;76. 如何选择 DOM 元素？&quot;">​</a></h3><p>选择 DOM 元素的方法有以下几种：</p><ul><li><code>getElementById()</code>：通过元素的 ID 选择元素。</li><li><code>getElementsByClassName()</code>：通过元素的类名选择元素，返回一个 HTMLCollection。</li><li><code>getElementsByTagName()</code>：通过元素的标签名选择元素，返回一个 HTMLCollection。</li><li><code>querySelector()</code>：通过 CSS 选择器选择第一个匹配的元素。</li><li><code>querySelectorAll()</code>：通过 CSS 选择器选择所有匹配的元素，返回一个 NodeList。</li></ul><h3 id="_77-如何创建和插入-dom-元素" tabindex="-1">77. 如何创建和插入 DOM 元素？ <a class="header-anchor" href="#_77-如何创建和插入-dom-元素" aria-label="Permalink to &quot;77. 如何创建和插入 DOM 元素？&quot;">​</a></h3><p>创建和插入 DOM 元素的方法如下：// 创建元素 const element = document.createElement(&#39;div&#39;); element.textContent = &#39;Hello, World!&#39;;</p><p>// 插入元素 const parent = document.getElementById(&#39;parent&#39;); parent.appendChild(element); // 在父元素末尾添加 parent.insertBefore(element, parent.firstChild); // 在父元素开头添加</p><h3 id="_78-如何删除-dom-元素" tabindex="-1">78. 如何删除 DOM 元素？ <a class="header-anchor" href="#_78-如何删除-dom-元素" aria-label="Permalink to &quot;78. 如何删除 DOM 元素？&quot;">​</a></h3><p>删除 DOM 元素的方法如下：const element = document.getElementById(&#39;element-to-remove&#39;); const parent = element.parentNode; parent.removeChild(element);或者更简洁的方法（ES6+）：element.remove();</p><h3 id="_79-什么是事件冒泡和事件捕获" tabindex="-1">79. 什么是事件冒泡和事件捕获？ <a class="header-anchor" href="#_79-什么是事件冒泡和事件捕获" aria-label="Permalink to &quot;79. 什么是事件冒泡和事件捕获？&quot;">​</a></h3><ul><li>事件冒泡：事件从触发元素开始，逐级向上传播到父元素，直到根元素（document 或 window）。</li><li>事件捕获：事件从根元素开始，逐级向下传播到触发元素。</li></ul><h3 id="_80-如何阻止事件冒泡" tabindex="-1">80. 如何阻止事件冒泡？ <a class="header-anchor" href="#_80-如何阻止事件冒泡" aria-label="Permalink to &quot;80. 如何阻止事件冒泡？&quot;">​</a></h3><p>可以使用<code>event.stopPropagation()</code>方法阻止事件冒泡。例如：element.addEventListener(&#39;click&#39;, function(event) { event.stopPropagation(); // 阻止事件冒泡 // 其他处理逻辑 });</p></div></div></main><footer class="VPDocFooter" data-v-5a987885 data-v-99cb0afc><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-99cb0afc><span class="visually-hidden" id="doc-footer-aria-label" data-v-99cb0afc>Pager</span><div class="pager" data-v-99cb0afc><!----></div><div class="pager" data-v-99cb0afc><a class="VPLink link pager-link next" href="/start-Learning/js-intermediate-interview-questions.html" data-v-99cb0afc><!--[--><span class="desc" data-v-99cb0afc>Next page</span><span class="title" data-v-99cb0afc>JS中级面试题</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api-examples.md\":\"D45LFarx\",\"index.md\":\"Cc75yMEy\",\"start-learning_js-advanced-interview-questions-2.md\":\"BTdWHl_m\",\"start-learning_js-advanced-interview-questions.md\":\"wp-WzeVB\",\"start-learning_js-intermediate-interview-questions.md\":\"CrSQxm4-\",\"start-learning_js-interview-questions.md\":\"DmHjffnW\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试\",\"description\":\"前端面试\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"sidebar\":[{\"text\":\"开始学习\",\"items\":[{\"text\":\"JS基础面试题\",\"link\":\"/start-Learning/js-interview-questions\"},{\"text\":\"JS中级面试题\",\"link\":\"/start-Learning/js-intermediate-interview-questions\"},{\"text\":\"JS高级面试题\",\"link\":\"/start-Learning/js-advanced-interview-questions\"},{\"text\":\"JS补充面试题\",\"link\":\"/start-Learning/js-advanced-interview-questions-2\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://gitee.com/Lalaniya/js-interview\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>